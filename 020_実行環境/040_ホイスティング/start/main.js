// ホイスティング・・・コンテキスト内で宣言した変数や関数の定義をコード実行前にメモリーに配置すること（宣言の巻き上げとも言う）
// 以下でa関数の呼び出しが宣言より先になってもコンソールに出力されるのだが
// それは、メモリ上に関数宣言が配置されているから

a();
function a() {
  let c = 1;
  // a内の関数コンテキストが生成されたタイミングで以下の処理がメモリに配置される
  // c変数はメモリ確保後、letなのでundefinedが設定されず、エラーを吐く
  console.log(c);
  // let c = 1;

  // d関数は関数コンテキストが生成された状態で宣言の部分もメモリ上に配置されているので、問題なく動く
  d();
  function d() {
    console.log('d is called');
  }
  console.log('a is called');
}
// a();

// 以下のb変数はコンソールの後に宣言してもundefinedで帰ってくる（ホイスティング時に設定されている）
// イメージとしては値の入っていないb変数のメモリを確保したのちコンソールに出力、その後、代入しているということになる
// なのでb = 0;の後であれば出力される

// var b = 0;

// まず、宣言後（宣言していない変数だとしても）、メモリ上でbを確保した状態でundefinedという値が自動で設定される（JSエンジンでホイスティング時に自動的に設定される）
// JavaScriptはまず宣言を見つけたらそのスペースを確保してundefindeを設定している
// var b;

// undefinedが出力
// console.log(b);

// b = 0;

// var b = 0;

// console.log(b);

// letをコンソール出力後に宣言すると「初期化されていません」とエラーになる
// letの場合はJSエンジンによって自動的にundefinedが設定されない、ホイスティング時に設定されないと言うこと
// 宣言が後になってしまうとメモリスペースは確保しているがエラーになってしまう
// constでも同様な挙動になる
console.log(b);

let b = 0;

// JSファイルが読みこれまれた時点でグローバルコンテキストが生成されるので、
// JSファイル直下に書かれているものはメモリが確保される

// 関数の宣言方法の種類
// 通常の関数宣言
function abcd() {}
// ・関数式
// 関数式だと関数を変数に入れている状況なので、呼び出しを関数より先にしてしまうと、
// undefinedが設定されず、エラーとなる
const ab = function () {};
// 無名関数
const abc = {
  de: function () {},
};
// アロー関数
const abcde = () => {};
