// 変数
// let,const ES6~
// var 非推奨

// ・宣言による機能の違い
// タイプ｜再宣言|再代入|スコープ|初期化
// let|×|●|ブロック|×
// const|×|×|ブロック|×
// var|●|●|関数|undefined

// スコープは宣言時に生成されるもの
// 初期化はホイスティングのこと

// データ型・・・変数が持っているデータの種類
// 型|英名|例
// 真偽値|boolean|true/false
// 数値|number|12
// 文字列|string|"Hello"
// undefined|undefined|undefined
// null|null|null
// シンボル|symbol|一意の値
// bigint|bigint|12n
// オブジェクト|object|{a:'value'}

// 暗黙的な型変換・・・変数が呼ばれた状況によって変数の方が自動的に変換されること
// JavaScriptは動的型付け言語
// ・変数宣言時に型の宣言なし
// ・変数を使用する状況によって、変数の型が変更される
// TypeScriptは静的型付け言語
// ・変数宣言時の型の宣言あり
// ・変数を使用するじょうきょうによらず、常に同じ型を保持

// 厳格な等価性 a === b ・・・型の比較あり
// 抽象的な等価性 a == b ・・・型の比較なし
// 等価性・・・値を比較した時に同じと見なせるかどうか

// falsy・・・booleanで真偽値に変換した場合にfalseになる値のこと
// falsyな値
// false,null,0,undefined,0n,NaN,""
// truthy・・・falsyな値以外のこと

// AND条件
// ⇨左側から順に確認して、falsyな値が存在した場合はその値をそのまま返す
//    ⇨truthyの場合は一番右側を返す
// OR条件
// ⇨左側から順に確認して、truthyな値が存在した場合はその値をそのまま返す
//    ⇨falsyの場合は一番右を返す

// プリミティブ型・・・string,null,number,symbol,boolean,bigint,undefined
// ・変数には値が格納される
// ・一度作成するとその値を変更することができない
// これをimmutable(不変)と呼ぶ
// ⇨letは変更されるのではないか
//    ⇨宣言時の値はメモリに格納され、変数がそれを参照している
//      ⇨再代入された値は別メモリに格納され、最初に参照して値から再代入された値に参照元を変更しているだけなので初期値は生きている

// オブジェクト・・・プリミティブ型以外
// ・変数には参照が格納される
// ・値を変更することができる
// これをmutable(可変)と呼ぶ
// ⇨オブジェクトの変数は中身では無くオブジェクト自体を参照しているので、中身が変わっても参照し続ける
//    ⇨また、オブジェクト自体はプロパティを参照していて、プロパティは値を参照しているという流れになっている

// オブジェクトは参照を名前付きで管理している入れ物

// 参照とコピー
// プリミティブ型のコピー・・・参照先の値がコピーされる
// let a = 'Hello';
// aをbに代入した時点で値のHelloは新しくメモリにコピーされ、bはコピーを参照する
// その為、aとHelloは変わらず、メモリに格納されている
// let b = a;
// 再代入された値は新しくメモリに格納され、bは参照先をByeに変更する
// b = 'Bye'

// オブジェクトのコピー・・・オブジェクトへの参照がコピーされる（プロパティはコピーされず）
// aは{}の参照⇨{}は中身のプロパティ{prop}を参照⇨プロパティは値を参照
// let a = {
//   prop: 'Hello'
// };

// aのオブジェクトをbに代入すると{}がコピーされ、bはコピー先を参照する(中身はコピーされず元を参照する)
// その為、中身のプロパティを変更するとaもbも変更されることになる
// let b = a;

// プロパティを再代入した場合は、新しいメモリ領域に格納されて、プロパティは参照先を変更する
// b.prop = 'Bye';

// 参照とconst
// プリミティブ型
// const a = 'Hello';
// 再代入後、新しい値はメモリに格納されるが、aはconstでロックされている為、参照先を変更することができない
// a = 'Bye';

// オブジェクト
// const a = {
//   prop: 'Hello';
// }
// オブジェクトを再代入すると、constでロックされる
// だが、aはオブジェクトの参照をロックしている為、プロパティ自体は変更可能となる
// a = {}

// 参照と引数
// 以下はlet a = b;と同じ
// function fn(a) {}
// let b = 0;
// fn(b);

// 参照と分割代入
// 分割代入・・・オブジェクトから特定のプロパティを抽出して宣言を行う
// const a = {
//   prop: 'hello',
// };
// propという新しい変数を宣言し、helloという値がメモリ上でコピーされ、変数propはコピーしたhelloを参照する
// let { prop } = a;
// 変数propに再代入すると学習した通り、参照先をhelloからbyeに変更される
// prop = 'bye';

// 基本的に分割代入で宣言する変数と取り出したいプロパティ名は同じにしないと値が取れない
// 値を変えたい場合は以下のようにすれば変えれる
// let { prop:b } = a;
// console.log(b);

// 参照の比較と値の比較
// ・プリミティブ型では値の比較
// ・オブジェクトは参照の比較
